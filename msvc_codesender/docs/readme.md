Основная задача микросервиса:
1) отправлять коды через смс или звонки
2) делать это оптимально с точки зрения $$ (то есть отправляет обычным шлюзом, если чел на фронте жмет что не пришло сообщение, то еще раз обычным шлюзом, но другим. Если снова жмет что не получил, то тогда отправляем через дорогой шлюз)

Как осуществляется работа:
1) из kafka получаем телефон, код и счетчик попыток
2) в зависимости от type (mobile/landline) записываем msg либо в sms либо в calls таблицы
3) воркеры, работающие по смс шлюзам, мониторят таблицу sms и в случае появления записи осуществляют отправку sms
4) ворверы, работающие на звонках, мониторя calls и звонят
5) само сообщение формируем тут (индивидуально с соблюдением требований конкретных шлюзов), чтоб не передавать лишние данные по сети


Используем Postgresql для высокой надежности
Можем позволить себе ввиду небольшой нагрузки 

1) сообщение получается с брокера и записывается в базу:
phone
message
retry
status not_sent
gateway default ""
2) висят много воркеров (столько сколько шлюзов) параллельно и забирают из базы каждый то, что ему допустимо. То есть воркеры с обычными шлюзами забирают себе retry = 1 или 2, а дорогие шлюзы забирают себе retry = 3. 
3) когда воркер берет сообщение, то делает апдейт в базе status = in_process. Если он не смог отправить, то возвращает status = not_sent. Но тут нужно подумать как сделать так, чтоб этот же воркер не забрал это сообщение снова. После успешной отправки status = sent и gateway=имя шлюза который отправил
4) обязательно нужно логировать в таблице логов кто из воркеров пытался отправить и не смог (писать ошибку в базу), а также кто смог отправить.

Почему не юзаем каналы или redis?
Меньше надежности (если выключаем микросервис или сбой), хотя при увеличении кол-ва сообщений этим можно пренебречь, так как надежность здесь эфемерна ввиду ненадежности доставки смс в целом. 
Но используя Postgresql мы сможем видеть в будущем какие шлюзы глючные, да и в целом сможем проверять работу воркеров.


TODO:
1) нужно написать отдельных воркеров для того, чтобы они перебирали wait которые созданы > 2 минут назад, так как смысла отправлять старые коды нет - ставим expired status. А сейчас реализовано на уровне воркеров-сендеров брать только свежие wait коды (до 2 минут).