Почему используются internal/ в каждом слое:
Защита от случайного нарушения архитектуры
Функции-реализации находятся в internal, и не видны другим слоям/пакетам, даже в рамках users:
handlers не может напрямую вызвать функцию из service/internal
repo/internal не может использовать biz/internal, и наоборот
Внешний доступ разрешен только через интерфейсы (*.go вне internal)


зачем разделение внутри на части типа users (со своими handlers, repo и пр), polls и пр:
1) смысловое разделение чтоб удобнее было программировать
2) навык повышается и если например users делаем по одним паттернам, то вероятно polls будет по-другому реализован, более продумано. Если бы все было в одной куче - было бы сложнее проводить такие действия
3) если polls будет тянуть на себя слишком много -> отделим в микросервис и разместим на другом сервере. То есть чтоб отделение проходило более удобно и менее бажно


почему используем для каждого внутреннего сервиса отдельную базу данных:
1) потому что мы не знаем какая будет нагрузка на базу и если вдруг она будет увеличиваться, то базы можно распределить по разным серверам
2) мы точно не знаем какая база данных будет эффективнее, поэтому оставим поле для маневра
3) транзакции: проектируем приложение таким образом, чтобы транзакции использовались только там, где без этого никак (например, казна, но там и будет одна база использоваться postgresql)


Валидация
1) первичная валидация входящих данных осуществляется в хендлере (handlers/validate и shared/validate) и в структуру записываются первичновалидированные данные. Потому что 1) это опасно так как можно первичную валидацию забыть сделать в бизнес-слое 2) потому что это вообще не бизнес-валидация и не имеет отношения к бизнес-слою
2) бизнес-валидация осуществляется в biz слое
3) непроверенные данные (после decode jsonа) кладем в unsafe структуру, затем проводим первичную валидацию и кладем в Validated структуру. Специально так разделяем, чтоб случайно не ушли unsafe данные в сервисный слой (репо+бизнес). В случае если забудем в Validated добавить, то это не так критично как unsafe пропустить

Тесты:
1) тестим микрофункции
2) проверяем методы структур на вызов всех микрофункций, чтоб нигде ничего не оставить случайно закомментированным

База данных и взаимодействие:
postgresql
обязательно юзаем pgxpool так как нам нужен именно pool для веб-сервера, иначе будет очередь и slow
конфиги базы данных находятся в соответствующих репо


Почему auth отделен в отдельный микросервис:
1) чтоб только на нем хранить приватный ключ для подписания токенов. Ввиду теоретического разделения монолита на несколько микросервисов это будет полезно, так как у каждого микросервиса будет только публичный ключ для проверки jwt токена, но не приватный.
2) если микросервис auth упадет по ряду причин, то ввиду jwt stateless к основному api у людей будет доступ